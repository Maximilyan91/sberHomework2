### Домашнее задание №2 "Коллекции".
#### Задача 1:
Создать массив с набором слов (10-20 слов, должны встречаться повторяющиеся). Найти и вывести список уникальных слов, из которых состоит массив (дубликаты не считаем).
Посчитать сколько раз встречается каждое слово.
#### Задача 2:
Написать простой класс Телефонный Справочник, который хранит в себе список фамилий и телефонных номеров. В этот телефонный справочник с помощью метода add() можно добавлять записи. С помощью метода get() искать номер телефона по фамилии. Следует учесть, что под одной фамилией может быть несколько телефонов (в случае однофамильцев), тогда при запросе такой фамилии должны выводиться все телефоны.


**Примечание**: Не реализуйте ничего лишнего, чего нет в задании (не добавляйте имя, отчество, адрес и проч, не надо делать взаимодействие через консоль и т.д.) Тестировать методы add() и get(), вызывая из метода main.

------------------------

### Результат
#### Задача 1:
На мой взгляд самым эффективным и элегантным способом удаления дубликатов из списка является перевод списка во множество.
Благодаря этому способу нет необходимости создавать циклы и конструкции if-else, а также соблюдается принцип KISS.
Отмечу, что данный способ чувствителен к регистру, но так как в задании сказано: "<u>Не реализуйте ничего лишнего, чего нет в задании</u>"
Он подходит для решения данной задачи.

Аналогично для подсчета и вывода на экран слова и количества его повторений
целесообразно использовать коллекцию Map, поместив ключом само слово, а значением - число повторений в списке.

#### Задача 2:
Во второй задаче также использовалась map для хранения контактов телефонной книги.
Благодаря этой структуре данных мы без дополнительного кода получаем список с уникальными элементами,
а благодаря множеству - в каждом bucket'е мы исключаем возможность дублирования телефонного номера.

#### Дополнительная задача:
В пакете additionalTask реализована задача измерения скорости выполнения
операций поиска элемента по индексу и вставки элемента в коллекцию.
Для достижения наиболее точных результатов было решено взять среднее значение
за несколько итераций операции в цикле. В свою очередь время первых итераций цикла
гораздо больше чем последующие. Это ускорение связано
с работой JIT-компилятора. В связи с этим среднее значение считается у последних
5 из 10 итераций в цикле. И после выводится в консоль среднее время в наносекундах.